package manifest

import (
	"bytes"
	"fmt"
	"github.com/Masterminds/sprig"
	"golang.org/x/sync/errgroup"
	"text/template"
)

// Generator describes how a manifest can generate other manifests.
type Generator struct {
	Name      string
	RangeOver [2]int
	Exclude   []int
	Template  string
	Context   map[string]interface{}
}

// Validate does just what you think it does.
func (g *Generator) Validate() error {
	if g.RangeOver[0] > g.RangeOver[1] || g.RangeOver[1] < g.RangeOver[0] {
		return fmt.Errorf("invalid range")
	}
	for _, item := range g.Exclude {
		if item < g.RangeOver[0] || item > g.RangeOver[1] {
			return fmt.Errorf("excludes must be within start / end")
		}
	}
	return nil
}

// NewFromGenerator generates potentially multiple manifests from a generator
// template embedded in another manifest.
func NewFromGenerator(g *Generator, host *Manifest) ([]*Manifest, error) {
	queue := make(chan *Manifest)
	process := errgroup.Group{}
	for i := g.RangeOver[0]; i <= g.RangeOver[1]; i++ {
		i := i
		process.Go(func() error {
			var buf bytes.Buffer
			for _, exclude := range g.Exclude {
				if i == exclude {
					return nil
				}
			}
			tmpl, tmplErr := template.New("").Funcs(sprig.TxtFuncMap()).Funcs(template.FuncMap{
				"count": func() int { return i },
			}).Parse(g.Template)
			if tmplErr != nil {
				return tmplErr
			}
			if err := tmpl.Execute(&buf, g.Context); err != nil {
				return err
			}
			manifests, newErr := New(buf.Bytes(), host.Selector.ID())
			if newErr != nil {
				return fmt.Errorf("\n%s\n%w", buf.String(), newErr)
			}
			for _, manifest := range manifests {
				manifest.source = fmt.Sprintf("generated by %s", host.Selector)
				queue <- manifest
			}
			return nil
		})
	}
	collector := errgroup.Group{}
	var manifests []*Manifest
	collector.Go(func() error {
		for manifest := range queue {
			manifests = append(manifests, manifest)
		}
		return nil
	})
	if err := process.Wait(); err != nil {
		return nil, err
	}
	close(queue)
	collector.Wait()
	return manifests, nil
}
