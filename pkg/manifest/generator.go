package manifest

import (
	"bytes"
	"fmt"
	"github.com/Masterminds/sprig"
	"golang.org/x/sync/errgroup"
	"text/template"
)

// Generator describes how a manifest can generate other manifests.
type Generator struct {
	Name     string
	Loops    []GeneratorRange
	Template string
	Context  map[string]interface{}
}

type GeneratorRange struct {
	Name  string
	Range [2]int
}

// Validate does just what you think it does.
func (g *Generator) Validate() error {
	for _, loop := range g.Loops {
		if loop.Range[0] > loop.Range[1] || loop.Range[1] < loop.Range[0] {
			return fmt.Errorf("invalid range")
		}
	}
	return nil
}

func (g *Generator) iterations() [][]int {
	var sets [][]int
	for _, loop := range g.Loops {
		var set []int
		for idx := loop.Range[0]; idx <= loop.Range[1]; idx++ {
			set = append(set, idx)
		}
		sets = append(sets, set)
	}
	return product(sets)
}

func product(sets [][]int) [][]int {
	var result [][]int
	if len(sets) == 0 {
		return result
	}
	if len(sets) == 1 {
		for _, vid := range sets[0] {
			result = append(result, []int{vid})
		}
		return result
	}
	collated := product(sets[1:])
	for _, vid := range sets[0] {
		for _, subset := range collated {
			result = append(result, append([]int{vid}, subset...))
		}
	}
	return result
}

func (g *Generator) Generate(host *Manifest) ([]*Manifest, error) {
	queue := make(chan *Manifest)
	collector := errgroup.Group{}
	var manifests []*Manifest
	collector.Go(func() error {
		for manifest := range queue {
			manifests = append(manifests, manifest)
		}
		return nil
	})
	process := errgroup.Group{}

	for _, iteration := range g.iterations() {
		iteration := iteration
		process.Go(func() error {
			var funcs map[string]interface{}
			funcs = map[string]interface{}{}
			for idx, loop := range g.Loops {
				idx, loop := idx, loop
				funcs[loop.Name] = func() interface{} { return iteration[idx] }
			}
			var buf bytes.Buffer
			tmpl, tmplErr := template.New("").Delims("((", "))").Funcs(funcs).Funcs(sprig.TxtFuncMap()).Parse(g.Template)
			if tmplErr != nil {
				return tmplErr
			}
			if err := tmpl.Execute(&buf, g.Context); err != nil {
				return err
			}
			manifests, newErr := New(buf.Bytes(), host.Selector.ID())
			if newErr != nil {
				return fmt.Errorf("\n%s\n%w", buf.String(), newErr)
			}
			for _, manifest := range manifests {
				manifest.Source = fmt.Sprintf("generated by %s", host.Selector)
				queue <- manifest
			}
			return nil
		})
	}
	if err := process.Wait(); err != nil {
		return nil, err
	}
	close(queue)
	collector.Wait()
	return manifests, nil
}
